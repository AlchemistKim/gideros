<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<link href="css/bundle_common.css" media="screen" rel="stylesheet" type="text/css" />
<link href="css/bundle_github.css" media="screen" rel="stylesheet" type="text/css" />
<link href="css/extra.css" media="screen" rel="stylesheet" type="text/css" />
<link href="prettify/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="prettify/prettify.js"></script>
<script type="text/javascript" src="prettify/lang-lua.js"></script>
<script type="text/javascript" src="jquery-1.4.4.min.js"></script>

<style>
</style>

<script>

$(document).ready(function(){

	$("code").addClass("prettyprint").addClass("lang-lua");


});


</script>

</head>


<body onload="prettyPrint()">

<div class="site">
<div id="readme" class="blob">
<div class="wikistyle">





	
		<h1>Events</h1>

<p>Events are the central mechanism to handle responses and
they allow to create interactive applications.</p>

<p>All classes that dispatch events inherit from <code>EventDispatcher</code>. The
target of an event is a listener function and an <em>optional</em> data value.
When an event is dispatched, the registered function is called.
If the optional data value is given, it is used as a first parameter
while calling the listener function.</p>

<p>In Gideros, events can be divided into two categories: <em>built-in events</em>
which are generated by the system (e.g. ENTER_FRAME event, touch events,
timer events, etc.) and <em>custom events</em> which can be generated by the user. According
to their event type, <em>built-in events</em> can be broadcasted to multiple
targets (e.g. ENTER_FRAME event, touch events, etc.) or can be dispatched to a
single target (e.g. timer event).</p>

<h2>ENTER_FRAME Event</h2>

<p>The Gideros runtime dispatches the built-in <code>Event.ENTER_FRAME</code> event to <code>Sprite</code>
instances before rendering the screen. Visual changes made by any <code>Event.ENTER_FRAME</code> listener
function will be visible at next frame.</p>

<p>This first basic example shows a moving sprite one pixel to the right at each frame.
In this example, <code>onEnterFrame</code> function increases the x-coordinate of a
sprite object at each frame:</p>

<pre><code>local sprite = Sprite.new()

local function onEnterFrame(event)
    sprite:setX(sprite:getX() + 1)
end

sprite:addEventListener(Event.ENTER_FRAME, onEnterFrame)
</code></pre>

<p>The next example shows 3 independent sprites moving one pixel
to the right at each frame. In this example, we use the optional
data parameter to move independent sprites with one common listener function:</p>

<pre><code>local sprite1 = Sprite.new()
local sprite2 = Sprite.new()
local sprite3 = Sprite.new()

local function onEnterFrame(self, event)
    self:setX(self:getX() + 1)
end

sprite1:addEventListener(Event.ENTER_FRAME, onEnterFrame, sprite1)
sprite2:addEventListener(Event.ENTER_FRAME, onEnterFrame, sprite2)
sprite3:addEventListener(Event.ENTER_FRAME, onEnterFrame, sprite3)
</code></pre>

<p>The last example shows subclassing of the <code>Sprite</code> class and registering <code>Event.ENTER_FRAME</code>:</p>

<pre><code>MySprite = Core.class(Sprite)

function MySprite:init()
    self:addEventListener(Event.ENTER_FRAME, self.onEnterFrame, self)
end

function MySprite:onEnterFrame(event)
    self:setX(self:getX() + 1)
end
</code></pre>

<p><strong>Note:</strong> <code>Event.ENTER_FRAME</code> event is dispatched to all <code>Sprite</code> instances no matter these
instances are on the scene tree or not.</p>

<h2>Mouse, Touch and Key Events</h2>

<p>Gideros runtime dispatches mouse and touch events when the the user&rsquo;s finger touches the screen.
Mouse events are mainly used in single-touch whereas touch events are used in multi-touch
applications. Key events are dispatched when user presses and releases a physical key on the keyboard.</p>

<p>The mouse, touch and key events are dispatched to <code>Sprite</code> instances which are on the scene tree.
If a <code>Sprite</code> instance is not on the scene tree, this instance doesn&rsquo;t receive mouse, touch and key events.</p>

<p><strong>Note:</strong> Even if touch or mouse doesn&rsquo;t hit the <code>Sprite</code> instance, the instance receive mouse/touch events.</p>

<p>The order of dispatch is determined by the hierachy of the scene tree.
The <code>Sprite</code> instance that is drawn last (top-most sprite) receives the event first.
The next sprite at the bottom of the top-most sprite receives the event second and so on.</p>

<p>For example, assume that we have an sprite hierachy like this:</p>

<p><img src="images/sprite_hierachy.png" alt="Sprite Hierachy" /></p>

<p>which is constructed by the code below:</p>

<pre><code>local A = Sprite.new()
local B = Sprite.new()
local C = Sprite.new()
local D = Sprite.new()
local E = Sprite.new()
local F = Sprite.new()

A:addChild(B)
A:addChild(C)
B:addChild(D)
B:addChild(E)
C:addChild(F)
</code></pre>

<p>In this hiearchy, the drawing order is A, B, C, D, E, F while mouse/touch event receive order is
F, E, D, C, B, A.</p>

<h3>Stopping an Event Dispatch</h3>

<p>It is possible to stop the propagation of mouse, touch and key events. To stop an event dispatch,
invoke the <code>Event:stopPropagation()</code> function on the <code>Event</code> object passed to the listener
function. In this example below, <code>MOUSE_DOWN</code> event is dispatched only to F, E, D and C:</p>

<pre><code>local A = Sprite.new()
local B = Sprite.new()
local C = Sprite.new()
local D = Sprite.new()
local E = Sprite.new()
local F = Sprite.new()

-- stop propagation at sprite C
C:addEventListener(Event.MOUSE_DOWN, function(event) event:stopPropagation() end)

A:addChild(B)
A:addChild(C)
B:addChild(D)
B:addChild(E)
C:addChild(F)
</code></pre>

<h2>Timer Events</h2>

<p>The <code>Timer</code> class is used for executing code at specified time intervals. Each <code>Timer</code>
object dispatches <code>Event.TIMER</code> event at specified frequency.</p>

<p>The steps to use <code>Timer</code> class are as follows:</p>

<ol>
<li><p>Create a new <code>Timer</code> object with specified frequency and specified total number of <code>Event.TIMER</code>
events to be triggered. For example, the following code sets the frequency to
1000 miliseconds and sets the count to 5.</p>

<pre><code>  local timer = Timer.new(1000, 5)
</code></pre></li>
<li><p>Register to the <code>Event.TIMER</code> event with a listener function:</p>

<pre><code> local function onTimer(event)
     -- will be executed 5 times at 1000 miliseconds intervals
 end

 timer:addEventListener(Event.TIMER, onTimer)
</code></pre></li>
<li><p>Start the timer.</p>

<pre><code> timer:start()
</code></pre></li>
<li><p>To stop the timer, you can use <code>Timer:stop()</code> function:</p>

<pre><code> timer:stop()
</code></pre></li>
<li><p><code>Event.TIMER_COMPLETE</code> event is triggered after finishing the specified number of timer events.</p>

<pre><code> local function onTimerComplete(event)
     -- will be executed after the specified number of timer events (5) are dispatched
 end

 timer:addEventListener(Event.TIMER_COMPLETE, onTimerComplete)
</code></pre></li>
</ol>


<p>Also, it is possible to pause and resume all the timers in your application. It is very useful when you
are implementing a pause/resume functionality in your game:</p>

<pre><code>Timer.pauseAllTimers()      -- pause all timers. if all timers are alredy paused, does nothing.
Timer.resumeAllTimers()     -- resume all timers. if all timers are alredy running, does nothing.
</code></pre>

<h2>ADDED_TO_STAGE and REMOVED_FROM_STAGE Events</h2>

<p>If a sprite is added to the scene tree, the sprite instance and all of it&rsquo;s descendants
receive <code>Event.ADDED_TO_STAGE</code> event. Similarly, if a sprite is removed from the scene tree,
the sprite instance and all of it&rsquo;s descendants receive <code>Event.REMOVED_FROM_STAGE</code> event. These
events are used to detect when a <code>Sprite</code> instance is added to, or removed from, the scene tree.
For example, by the help of these events, it is possible to register <code>Event.ENTER_FRAME</code> event only
for the sprites that are on the scene tree:</p>

<pre><code>MySprite = Core.class(Sprite)

function MySprite:init()
    self:addEventListener(Event.ADDED_TO_STAGE, self.onAddedToStage, self)
    self:addEventListener(Event.REMOVED_FROM_STAGE, self.onRemovedFromStage, self)
end

function MySprite:onAddedToStage(event)
    self:addEventListener(Event.ENTER_FRAME, self.onEnterFrame, self)
end

function MySprite:onRemovedFromStage(event)
    self:removeEventListener(Event.ENTER_FRAME, self.onEnterFrame, self)
end

function MySprite:onEnterFrame(event)
    -- enter frame logic
end
</code></pre>

<h2>Custom Events</h2>

<p>To dispatch a new custom, user defined event, create the event with <code>Event.new()</code> function and
dispatch it with <code>EventDispatcher:dispatchEvent()</code>.</p>

<pre><code>ClassA = Core.class(EventDispatcher)
ClassB = Core.class(EventDispatcher)

function ClassA:funcA(event)
    print("funcA", self, event:getType(), event:getTarget())
end

local a = ClassA.new()
local b = ClassB.new()

b:addEventListener("myevent", a.funcA, a)   -- when b dispatches an "myevent" event,
                                            -- a.funcA will be called with 'a'
                                            -- as first parameter

b:dispatchEvent(Event.new("myevent"))       -- will print "funcA"
</code></pre>

<h2>List of all Built-in Events</h2>

<h3>ENTER_FRAME</h3>

<p>Dispatched to all <code>Sprite</code> instances before rendering the screen.</p>

<ul>
<li><strong>event.frameCount</strong>: The total number of frames that have passed since the start of the application</li>
<li><strong>event.time</strong>: Time in seconds since the start of the application</li>
<li><strong>event.deltaTime</strong>: The time in seconds between the last frame and the current frame</li>
</ul>


<h3>ADDED_TO_STAGE</h3>

<p>Dispatched when target <code>Sprite</code> instance is added to the stage.</p>

<h3>REMOVED_FROM_STAGE</h3>

<p>Dispatched when target <code>Sprite</code> instance is removed from the stage.</p>

<h3>MOUSE_DOWN</h3>

<p>Dispatched to all <code>Sprite</code> instances on the scene tree when user presses the mouse button or starts the first touch.</p>

<ul>
<li><strong>event.x</strong>: The x-coordinate of the mouse or touch</li>
<li><strong>event.y</strong>: The y-coordinate of the mouse or touch</li>
</ul>


<h3>MOUSE_MOVE</h3>

<p>Dispatched to all <code>Sprite</code> instances on the scene tree when user moves the mouse or moves the first touch.</p>

<ul>
<li><strong>event.x</strong>: The x-coordinate of the mouse or touch</li>
<li><strong>event.y</strong>: The y-coordinate of the mouse or touch</li>
</ul>


<h3>MOUSE_UP</h3>

<p>Dispatched to all <code>Sprite</code> instances on the scene tree when user releases the mouse button or ends the first touch.</p>

<ul>
<li><strong>event.x</strong>: The x-coordinate of the mouse or touch</li>
<li><strong>event.y</strong>: The y-coordinate of the mouse or touch</li>
</ul>


<h3>TOUCHES_BEGIN</h3>

<p>Dispatched to all <code>Sprite</code> instances on the scene tree when one or more fingers touch down.</p>

<ul>
<li><strong>event.touch</strong>: A table with fields x, y and id which specifies the coordinates and id of the current touch</li>
<li><strong>event.allTouches</strong>: Array of all touches where each element contains x, y and id</li>
</ul>


<p>For example, you can print the x, y and id properties of current touch and all touches as:</p>

<pre><code>local function onTouchesBegin(event)
    print(event.touch.x, event.touch.y, event.touch.id)
    for i=1,#event.allTouches do
        print(event.allTouches[i].x, event.allTouches[i].y, event.allTouches[i].id)
    end
end
</code></pre>

<h3>TOUCHES_MOVE</h3>

<p>Dispatched to all <code>Sprite</code> instances on the scene tree when one or more fingers move.</p>

<ul>
<li><strong>event.touch</strong>: A table with fields x, y and id which specifies the coordinates and id of the current touch</li>
<li><strong>event.allTouches</strong>: Array of all touches where each element contains x, y and id</li>
</ul>


<h3>TOUCHES_END</h3>

<p>Dispatched to all <code>Sprite</code> instances on the scene tree when one or more fingers are raised.</p>

<ul>
<li><strong>event.touch</strong>: A table with fields x, y and id which specifies the coordinates and id of the current touch</li>
<li><strong>event.allTouches</strong>: Array of all touches where each element contains x, y and id</li>
</ul>


<h3>TOUCHES_CANCEL</h3>

<p>Dispatched to all <code>Sprite</code> instances on the scene tree when a system event (such as a low-memory warning) cancels a touch event.</p>

<ul>
<li><strong>event.touch</strong>: A table with fields x, y and id which specifies the coordinates and id of the current touch</li>
<li><strong>event.allTouches</strong>: Array of all touches where each element contains x, y and id</li>
</ul>


<h3>KEY_DOWN</h3>

<p>Dispatched to all <code>Sprite</code> instances on the scene tree when user presses a physical key on the keyboard.</p>

<ul>
<li><strong>event.keyCode</strong>: The key code value of the key pressed</li>
</ul>


<h3>KEY_UP</h3>

<p>Dispatched to all <code>Sprite</code> instances on the scene tree when user releases a physical key on the keyboard.</p>

<ul>
<li><strong>event.keyCode</strong>: The key code value of the key released</li>
</ul>


<h3>APPLICATION_START</h3>

<p>Dispatched to all event listeners (broadcast event) right after the application is launched and all Lua codes are executed.</p>

<h3>APPLICATION_EXIT</h3>

<p>Dispatched to all event listeners (broadcast event) when the application is about to exit. If an application is forced
to be terminated (e.g. by double tapping the home button and kill the application), this event may
not be dispatched. If you want to save your game state before exiting, save your state also on
<code>APPLICATION_SUSPEND</code> event.</p>

<h3>APPLICATION_SUSPEND</h3>

<p>Dispatched to all event listeners (broadcast event) when when the application is about to move from the active to
inactive state. When an application is inactive, <code>Event.ENTER_FRAME</code> and <code>Event.TIMER</code> events are not dispatched until the
application is resumed.</p>

<h3>APPLICATION_RESUME</h3>

<p>Dispatched to all event listeners (broadcast event) when the application is moved from the inactive to active state.</p>

<h3>APPLICATION_BACKGROUND</h3>

<p>Dispatched to all event listeners (broadcast event) when the application is now in the background.</p>

<h3>APPLICATION_FOREGROUND</h3>

<p>Dispatched to all event listeners (broadcast event) when the application is about to enter the foreground.</p>

<h3>TIMER</h3>

<p>Dispatched whenever a <code>Timer</code> object reaches an interval specified according to the delay property.</p>

<h3>TIMER_COMPLETE</h3>

<p>Dispatched whenever a <code>Timer</code> object has completed the number of requests specified according to the repeatCount property.</p>

<h3>COMPLETE</h3>

<p>Dispatched when:</p>

<ul>
<li>a sound channel has finished playing.</li>
<li>after all data is received and placed in the <code>event.data</code> field</li>
</ul>


<h3>ERROR</h3>

<p>Dispatched when <code>UrlLoader</code> fails and terminates the download.</p>

<h3>PROGRESS</h3>

<p>Dispatched by <code>UrlLoader</code> as the notification of how far the download has progressed.</p>

<ul>
<li><strong>event.bytesLoaded</strong>: The number of bytes loaded</li>
<li><strong>event.bytesTotal</strong>: The total number of bytes that will be loaded</li>
</ul>


<h3>BEGIN_CONTACT</h3>

<p>Dispatched by <code>b2.World</code> when two fixtures begin to overlap. This is dispatched for sensors and non-sensors. This event can only occur inside the time step.</p>

<ul>
<li><strong>event.contact</strong>: The contact</li>
<li><strong>event.fixtureA</strong>: The first fixture in this contact</li>
<li><strong>event.fixtureB</strong>: The second fixture in this contact</li>
</ul>


<h3>END_CONTACT</h3>

<p>Dispatched by <code>b2.World</code> when two fixtures cease to overlap. This is dispatched for sensors and non-sensors. This may be dispatched when a body is destroyed, so this event can occur outside the time step.</p>

<ul>
<li><strong>event.contact</strong>: The contact</li>
<li><strong>event.fixtureA</strong>: The first fixture in this contact</li>
<li><strong>event.fixtureB</strong>: The second fixture in this contact</li>
</ul>


<h3>PRE_SOLVE</h3>

<p>Dispatched by <code>b2.World</code> after collision detection, but before collision resolution.</p>

<ul>
<li><strong>event.contact</strong>: The contact</li>
<li><strong>event.fixtureA</strong>: The first fixture in this contact</li>
<li><strong>event.fixtureB</strong>: The second fixture in this contact</li>
</ul>


<h3>POST_SOLVE</h3>

<p>Dispatched by <code>b2.World</code> after collision resolution.</p>

<ul>
<li><strong>event.contact</strong>: The contact</li>
<li><strong>event.fixtureA</strong>: The first fixture in this contact</li>
<li><strong>event.fixtureB</strong>: The second fixture in this contact</li>
<li><strong>event.maxImpulse</strong>: Maximum of the normal impulses</li>
</ul>

	



</div>
</div>
</div>

</body>
</html>
