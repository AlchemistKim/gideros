

= Events =

Events are the central mechanism to handle responses and
they allow to create interactive applications.

All classes that dispatch events inherit from <code>EventDispatcher</code>. The
target of an event is a listener function and an ''optional'' data value.
When an event is dispatched, the registered function is called.
If the optional data value is given, it is used as a first parameter
while calling the listener function.

In Gideros, events can be divided into two categories: ''built-in events''
which are generated by the system (e.g. ENTER_FRAME event, touch events,
timer events, etc.) and ''custom events'' which can be generated by the user. According
to their event type, ''built-in events'' can be broadcasted to multiple
targets (e.g. ENTER_FRAME event, touch events, etc.) or can be dispatched to a
single target (e.g. timer event).

== ENTER_FRAME Event ==

The Gideros runtime dispatches the built-in <code>Event.ENTER_FRAME</code> event to <code>Sprite</code>
instances before rendering the screen. Visual changes made by any <code>Event.ENTER_FRAME</code> listener
function will be visible at next frame.

This first basic example shows a moving sprite one pixel to the right at each frame.
In this example, <code>onEnterFrame</code> function increases the x-coordinate of a
sprite object at each frame:

<source lang="lua">
local sprite = Sprite.new()

local function onEnterFrame(event)
	sprite:setX(sprite:getX() + 1)
end

sprite:addEventListener(Event.ENTER_FRAME, onEnterFrame)
</source>

The next example shows 3 independent sprites moving one pixel
to the right at each frame. In this example, we use the optional
data parameter to move independent sprites with one common listener function:

<source lang="lua">
local sprite1 = Sprite.new()
local sprite2 = Sprite.new()
local sprite3 = Sprite.new()

local function onEnterFrame(self, event)
	self:setX(self:getX() + 1)
end

sprite1:addEventListener(Event.ENTER_FRAME, onEnterFrame, sprite1)
sprite2:addEventListener(Event.ENTER_FRAME, onEnterFrame, sprite2)
sprite3:addEventListener(Event.ENTER_FRAME, onEnterFrame, sprite3)
</source>

The last example shows subclassing of the <code>Sprite</code> class and registering <code>Event.ENTER_FRAME</code>:

<source lang="lua">
MySprite = gideros.class(Sprite)

function MySprite:init()
	self:addEventListener(Event.ENTER_FRAME, self.onEnterFrame, self)
end

function MySprite:onEnterFrame(event)
	self:setX(self:getX() + 1)
end
</source>

'''Note:''' <code>Event.ENTER_FRAME</code> event is dispatched to all <code>Sprite</code> instances no matter these
instances are on the scene tree or not.

== Mouse and Touch Events ==

Gideros runtime dispatches mouse and touch events when the the user's finger touches the screen.
Mouse events are mainly used in single-touch whereas touch events are used in multi-touch
applications.

The mouse and touch events are dispatched to <code>Sprite</code> instances which are on the scene tree.
If a <code>Sprite</code> instance is not on the scene tree, this instance doesn't receive mouse and touch events.

'''Note:''' Even if touch or mouse doesn't hit the <code>Sprite</code> instance, the instance
receive mouse/touch events.

The order of dispatch is determined by the hierachy of the scene tree.
The <code>Sprite</code> instance that is drawn last (top-most sprite) receives the event first.
The next sprite at the bottom of the top-most sprite receives the event second and so on.

For example, assume that we have an sprite hierachy like this:

[[File:sprite_hierachy.png]]

which is constructed by the code below:

<source lang="lua">
local A = Sprite.new()
local B = Sprite.new()
local C = Sprite.new()
local D = Sprite.new()
local E = Sprite.new()
local F = Sprite.new()

A:addChild(B)
A:addChild(C)
B:addChild(D)
B:addChild(E)
C:addChild(F)
</source>

In this hiearchy, the drawing order is A, B, C, D, E, F while mouse/touch event receive order is
F, E, D, C, B, A.

=== Stopping an Event Dispatch ===

It is possible to stop the propagation of mouse and touch events. To stop an event dispatch,
invoke the <code>Event:stopPropagation()</code> function on the <code>Event</code> object passed to the listener
function. In this example below, <code>MOUSE_DOWN</code> event is dispatched only to F, E, D and C:

<source lang="lua">
local A = Sprite.new()
local B = Sprite.new()
local C = Sprite.new()
local D = Sprite.new()
local E = Sprite.new()
local F = Sprite.new()

-- stop propagation at sprite C
C:addEventListener(Event.MOUSE_DOWN, function(event) event:stopPropagation() end)

A:addChild(B)
A:addChild(C)
B:addChild(D)
B:addChild(E)
C:addChild(F)
</source>

== Timer Events ==

The <code>Timer</code> class is used for executing code at specified time intervals. Each <code>Timer</code>
object dispatches <code>Event.TIMER</code> event at specified frequency.

The steps to use <code>Timer</code> class are as follows:

1. Create a new <code>Timer</code> object with specified frequency and specified total number of <code>Event.TIMER</code>
events to be triggered. For example, the following code sets the frequency to
1000 miliseconds and sets the count to 5.

<source lang="lua">
	local timer = Timer.new(1000, 5)
</source>

2. Register to the <code>Event.TIMER</code> event with a listener function:

<source lang="lua">
	local function onTimer(event)
		-- will be executed 5 times at 1000 miliseconds intervals
	end
	
	timer:addEventListener(Event.TIMER, onTimer)
</source>

3. Start the timer.

<source lang="lua">
	timer:start()
</source>

4. To stop the timer, you can use <code>Timer:stop()</code> function:

<source lang="lua">
	timer:stop()
</source>

5. <code>Event.TIMER_COMPLETE</code> event is triggered after finishing the specified number of timer events.

<source lang="lua">
	local function onTimerComplete(event)
		-- will be executed after the specified number of timer events (5) are dispatched
	end
	
	timer:addEventListener(Event.TIMER_COMPLETE, onTimerComplete)
</source>

Also, it is possible to pause and resume all the timers in your application. It is very useful when you
are implementing a pause/resume functionality in your game:

<source lang="lua">
Timer.pauseAllTimers()		-- pause all timers. if all timers are alredy paused, does nothing.
Timer.resumeAllTimers()		-- resume all timers. if all timers are alredy running, does nothing.
</source>

== ADDED_TO_STAGE and REMOVED_FROM_STAGE Events ==

If a sprite is added to the scene tree, the sprite instance and all of it's descendants
receive <code>Event.ADDED_TO_STAGE</code> event. Similarly, if a sprite is removed from the scene tree,
the sprite instance and all of it's descendants receive <code>Event.REMOVED_FROM_STAGE</code> event. These
events are used to detect when a <code>Sprite</code> instance is added to, or removed from, the scene tree.
For example, by the help of these events, it is possible to register <code>Event.ENTER_FRAME</code> event only
for the sprites that are on the scene tree:

<source lang="lua">
MySprite = gideros.class(Sprite)

function MySprite:init()
	self:addEventListener(Event.ADDED_TO_STAGE, self.onAddedToStage, self)
	self:addEventListener(Event.REMOVED_FROM_STAGE, self.onRemovedFromStage, self)
end

function MySprite:onAddedToStage(event)
	self:addEventListener(Event.ENTER_FRAME, self.onEnterFrame, self)
end

function MySprite:onRemovedFromStage(event)
	self:removeEventListener(Event.ENTER_FRAME, self.onEnterFrame, self)
end

function MySprite:onEnterFrame(event)
	-- enter frame logic
end
</source>

== Custom Events ==

To dispatch a new custom, user defined event, create the event with <code>Event.new()</code> function and
dispatch it with <code>EventDispatcher:dispatchEvent()</code>.

<source lang="lua">
ClassA = gideros.class(EventDispatcher)
ClassB = gideros.class(EventDispatcher)

function ClassA:funcA(event)
	print("funcA", self, event:getType(), event:getTarget())
end

local a = ClassA.new()
local b = ClassB.new()

b:addEventListener("myevent", a.funcA, a)	-- when b dispatches an "myevent" event,
											-- a.funcA will be called with 'a'
											-- as first parameter

b:dispatchEvent(Event.new("myevent"))		-- will print "funcA"
</source>

== List of all Built-in Events ==

=== ENTER_FRAME ===
Dispatched to all <code>Sprite</code> instances before rendering the screen.

* '''event.frameCount''': The total number of frames that have passed since the start of the application
* '''event.time''': Time in seconds since the start of the application
* '''event.deltaTime''': The time in seconds between the last frame and the current frame

=== ADDED_TO_STAGE ===
Dispatched when target <code>Sprite</code> instance is added to the stage.

=== REMOVED_FROM_STAGE ===
Dispatched when target <code>Sprite</code> instance is removed from the stage.

=== MOUSE_DOWN ===
Dispatched to all <code>Sprite</code> instances on the scene tree when user presses the mouse button or starts the first touch.

* '''event.x''': The x-coordinate of the mouse or touch
* '''event.y''': The y-coordinate of the mouse or touch
* '''event.tapCount''': The number of times the finger or mouse was tapped for this event

=== MOUSE_MOVE ===
Dispatched to all <code>Sprite</code> instances on the scene tree when user moves the mouse or moves the first touch.

* '''event.x''': The x-coordinate of the mouse or touch
* '''event.y''': The y-coordinate of the mouse or touch
* '''event.tapCount''': The number of times the finger or mouse was tapped for this event

=== MOUSE_UP ===
Dispatched to all <code>Sprite</code> instances on the scene tree when user releases the mouse button or ends the first touch.

* '''event.x''': The x-coordinate of the mouse or touch
* '''event.y''': The y-coordinate of the mouse or touch
* '''event.tapCount''': The number of times the finger or mouse was tapped for this event

=== TOUCHES_BEGIN ===
Dispatched to all <code>Sprite</code> instances on the scene tree when one or more fingers touch down.

* '''event.touches''': Array of current touches where each element contains x, y and tapCount
* '''event.allTouches''': Array of all touches where each element contains x, y and tapCount

For example, you can print the x, y and tapCount properties of all touches as:

<source lang="lua">
local function onTouchesBegin(event)
	for i=1,#event.allTouches do
		print(event.allTouches[i].x, event.allTouches[i].y, event.allTouches[i].tapCount)
	end
end
</source>

=== TOUCHES_MOVE ===
Dispatched to all <code>Sprite</code> instances on the scene tree when one or more fingers move.

* '''event.touches''': Array of current touches where each element contains x, y and tapCount
* '''event.allTouches''': Array of all touches where each element contains x, y and tapCount

=== TOUCHES_END ===
Dispatched to all <code>Sprite</code> instances on the scene tree when one or more fingers are raised.

* '''event.touches''': Array of current touches where each element contains x, y and tapCount
* '''event.allTouches''': Array of all touches where each element contains x, y and tapCount

=== TOUCHES_CANCEL ===
Dispatched to all <code>Sprite</code> instances on the scene tree when a system event (such as a low-memory warning) cancels a touch event.

* '''event.touches''': Array of current touches where each element contains x, y and tapCount
* '''event.allTouches''': Array of all touches where each element contains x, y and tapCount

=== APPLICATION_START ===
Dispatched to all event listeners (broadcast event) right after the application is launched and all Lua codes are executed.

=== APPLICATION_EXIT ===
Dispatched to all event listeners (broadcast event) when the application is about to exit. If an application is forced
to be terminated (e.g. by double tapping the home button and kill the application), this event may 
not be dispatched. If you want to save your game state before exiting, save your state also on
<code>APPLICATION_SUSPEND</code> event.

=== APPLICATION_SUSPEND ===
Dispatched to all event listeners (broadcast event) when the application goes to background. When an application 
goes to background, <code>ENTER_FRAME</code> and <code>TIMER</code> events are not dispatched until the application is resumed from background.

=== APPLICATION_RESUME ===
Dispatched to all event listeners (broadcast event) when the application is resumed from background.

=== SOUND_COMPLETE ===
Dispatched when a sound has finished playing.

=== TIMER ===
Dispatched whenever a <code>Timer</code> object reaches an interval specified according to the delay property.

=== TIMER_COMPLETE ===
Dispatched whenever a <code>Timer</code> object has completed the number of requests specified according to the repeatCount property.

=== COMPLETE ===
Dispatched after all data is received and placed in the <code>data</code> property of the <code>URLLoader</code> object.

=== ERROR ===
Dispatched when <code>URLLoader</code> fails and terminates the download.

=== PROGRESS ===
Dispatched by <code>URLLoader</code> as the notification of how far the download has progressed.

* '''event.bytesLoaded''': The number of bytes loaded
* '''event.bytesTotal''': The total number of bytes that will be loaded

=== BEGIN_CONTACT ===
Dispatched by <code>b2.World</code> when two fixtures begin to overlap. This is dispatched for sensors and non-sensors. This event can only occur inside the time step.

* '''event.fixtureA''': The first fixture in this contact
* '''event.fixtureB''': The second fixture in this contact

=== END_CONTACT ===
Dispatched by <code>b2.World</code> when two fixtures cease to overlap. This is dispatched for sensors and non-sensors. This may be dispatched when a body is destroyed, so this event can occur outside the time step.

* '''event.fixtureA''': The first fixture in this contact
* '''event.fixtureB''': The second fixture in this contact

=== PRE_SOLVE ===
Dispatched by <code>b2.World</code> after collision detection, but before collision resolution.

* '''event.fixtureA''': The first fixture in this contact
* '''event.fixtureB''': The second fixture in this contact

=== POST_SOLVE ===
Dispatched by <code>b2.World</code> after collision resolution.

* '''event.fixtureA''': The first fixture in this contact
* '''event.fixtureB''': The second fixture in this contact

