#include "box2dbinder.h"
#include <Box2D/Box2D.h>
#include "stackchecker.h"
#include <eventdispatcher.h>
#include "b2contactpointevent.h"
#include <gstatus.h>

static void getb2(lua_State* L)
{
	StackChecker checker(L, "getb2", 0);
	lua_getfield(L, LUA_ENVIRONINDEX, "b2");
	lua_pushvalue(L, -2);
	lua_rawget(L, -2);
	lua_remove(L, -2);
	lua_remove(L, -2);
}

static void getb2(lua_State* L, void* ptr)
{
	lua_pushlightuserdata(L, ptr);
	getb2(L);
}

static void setb2(lua_State* L)
{
	StackChecker checker(L, "setb2", -2);
	lua_getfield(L, LUA_ENVIRONINDEX, "b2");
	lua_pushvalue(L, -3);
	lua_pushvalue(L, -3);
	lua_rawset(L, -3);
	lua_pop(L, 3);
}

class b2WorldED : public b2World, public EventDispatcher
{
public:
	b2WorldED(const b2Vec2& gravity, bool doSleep) : b2World(gravity, doSleep)
	{
		m_destructionListener = 0;
		m_contactListener = 0;
	}

	virtual ~b2WorldED()
	{
		delete m_destructionListener;
		delete m_contactListener;
	}

	void SetDestructionListener(b2DestructionListener* listener)
	{
		m_destructionListener = listener;
		b2World::SetDestructionListener(listener);
	}

	b2DestructionListener* GetDestructionListener() const
	{
		return m_destructionListener;
	}

	void SetContactListener(b2ContactListener* listener)
	{
		m_contactListener = listener;
		b2World::SetContactListener(listener);
	}

	b2ContactListener* GetContactListener() const
	{
		return m_contactListener;
	}

private:
	b2DestructionListener* m_destructionListener;
	b2ContactListener* m_contactListener;
};

#if 0

/*
class EventContactListener : public b2ContactListener
{
public:
	EventContactListener(lua_State* L, b2WorldED* world) : L(L), world(world) {}

	void call(const b2ContactPointEvent::Type& type, const b2ContactPoint* point)
	{
		getb2(L, world);

		if (!lua_isnil(L, -1))
		{
			lua_getfield(L, -1, "dispatchEvent");

			lua_pushvalue(L, -2); // create copy of world

			lua_getglobal(L, "b2ContactPointEvent");
			lua_getfield(L, -1, "new");
			lua_remove(L, -2);

			b2ContactPointEvent event(type, point);
			lua_pushlightuserdata(L, &event);
			lua_call(L, 1, 1); // call b2ContactPointEvent.new

			lua_call(L, 2, 0); // call world:dispatchEvent(event)
			
			lua_pop(L, 1);
		}
		else
			lua_pop(L, 1);
	}
	
	virtual void Add(const b2ContactPoint* point)
    {
		call(b2ContactPointEvent::ADD, point);
	}

	virtual void Persist(const b2ContactPoint* point)
    {
		call(b2ContactPointEvent::PERSIST, point);
	}
	
	virtual void Remove(const b2ContactPoint* point)
    {
		call(b2ContactPointEvent::REMOVE, point);
	}

    virtual void Result(const b2ContactResult* point)
    {
        // handle results
    }

	lua_State* L;
	b2WorldED* world;
};
*/


/*
// bu obsolute
class LuaContactListener : public b2ContactListener
{
public:
	LuaContactListener(lua_State* L, b2World* world) : L(L), world(world) {}



	void call(const b2ContactPoint* point, const char* func)
	{
		StackChecker checker(L, "LuaContactListener::call", 0);

		lua_pushlightuserdata(L, world);
		getb2(L);

		lua_getfield(L, -1, func);

		lua_remove(L, -2); // remove world

		if (!lua_isnil(L, -1))
		{
			lua_getglobal(L, "b2ContactPoint");
			lua_getfield(L, -1, "new");
			lua_remove(L, -2);
			lua_pushlightuserdata(L, const_cast<b2ContactPoint*>(point));
			lua_call(L, 1, 1); // call b2ContactPoint.new

			lua_call(L, 1, 0); // call world.func
		}
		else
			lua_pop(L, 1); // remove nil
	}
	
	virtual void Add(const b2ContactPoint* point)
    {
		call(point, "__ContactListener_Add");
    }
    
	virtual void Persist(const b2ContactPoint* point)
    {
		call(point, "__ContactListener_Persist");
    }
    
	virtual void Remove(const b2ContactPoint* point)
    {
		call(point, "__ContactListener_Remove");
    }
    
    virtual void Result(const b2ContactResult* point)
    {
        // handle results
    }

	lua_State* L;
	b2World* world;
};
*/

#endif


class EventContactListener : public b2ContactListener
{
public:
	EventContactListener(lua_State* L, b2WorldED* world) : L(L), world(world) {}

private:
	void dispatchEvent(const b2ContactEvent::Type& type, b2Contact* contact, const b2Manifold* oldManifold, const b2ContactImpulse* impulse)
	{
		getb2(L, world);

		if (!lua_isnil(L, -1))
		{
			lua_getfield(L, -1, "dispatchEvent");

			lua_pushvalue(L, -2); // create copy of world

/*
			lua_getglobal(L, "b2ContactEvent");
			lua_getfield(L, -1, "new");
			lua_remove(L, -2);

			b2ContactEvent event(type, contact, oldManifold, impulse);
			lua_pushlightuserdata(L, &event);
			lua_call(L, 1, 1); // call b2ContactEvent.new
*/
/*
			lua_getglobal(L, "Event");
			lua_getfield(L, -1, "new");
			lua_remove(L, -2);				// remove global "Event"

			lua_pushstring(L, type.type());
			lua_call(L, 1, 1); // call Event.new
			*/

			if (type.id() == b2ContactEvent::BEGIN_CONTACT.id())
				lua_getfield(L, -1, "__beginContactEvent");
			else if (type.id() == b2ContactEvent::END_CONTACT.id())
				lua_getfield(L, -1, "__endContactEvent");
			else if (type.id() == b2ContactEvent::PRE_SOLVE.id())
				lua_getfield(L, -1, "__preSolveEvent");
			else if (type.id() == b2ContactEvent::POST_SOLVE.id())
				lua_getfield(L, -1, "__postSolveEvent");

			getb2(L, contact->GetFixtureA());
			lua_setfield(L, -2, "fixtureA");

			getb2(L, contact->GetFixtureB());
			lua_setfield(L, -2, "fixtureB");

			lua_call(L, 2, 0); // call world:dispatchEvent(event)
			
			lua_pop(L, 1);
		}
		else
			lua_pop(L, 1); 
	}
	
public:
	virtual void BeginContact(b2Contact* contact)
	{
		dispatchEvent(b2ContactEvent::BEGIN_CONTACT, contact, 0, 0);
	}
	
	virtual void EndContact(b2Contact* contact)
	{
		dispatchEvent(b2ContactEvent::END_CONTACT, contact, 0, 0);
	}
	
	virtual void PreSolve(b2Contact* contact, const b2Manifold* oldManifold)
	{
		dispatchEvent(b2ContactEvent::PRE_SOLVE, contact, oldManifold, 0);
	}

	virtual void PostSolve(b2Contact* contact, const b2ContactImpulse* impulse)
	{
		dispatchEvent(b2ContactEvent::POST_SOLVE, contact, 0, impulse);
	}

private:
	lua_State* L;
	b2WorldED* world;
};


class DestructionListener : public b2DestructionListener
{
public:
	DestructionListener(lua_State* L, b2WorldED* world) : L(L), world(world)
	{

	}

	virtual void SayGoodbye(b2Joint* joint)
	{

	}

	virtual void SayGoodbye(b2Fixture* fixture)
	{
		StackChecker checker(L, "DestructionListener::SayGoodbye", 0);

		getb2(L, fixture);
		lua_getfield(L, -1, "__body");
		lua_getfield(L, -1, "__fixtures");

		lua_pushvalue(L, -3);
		lua_pushnil(L);
		lua_settable(L, -3);
	
		Binder binder(L);
		binder.setInstance(-3, 0);

		lua_pop(L, 3);
	}

private:
	lua_State* L;
	b2WorldED* world;
};

Box2DBinder::Box2DBinder(lua_State* L)
{
	Binder binder(L);

	static const luaL_Reg b2Vec2_functionList[] = {
		{"getX", b2Vec2_getX},
		{"getY", b2Vec2_getY},
		{"setX", b2Vec2_setX},
		{"setY", b2Vec2_setY},
		{"Set", b2Vec2_Set},
		{NULL, NULL},
	};
	binder.createClass("b2Vec2", NULL, b2Vec2_create, b2Vec2_destruct, b2Vec2_functionList);


	static const luaL_Reg b2AABB_functionList[] = {
		{NULL, NULL},
	};
	binder.createClass("b2AABB", NULL, b2AABB_create, b2AABB_destruct, b2AABB_functionList);


	static const luaL_Reg b2World_functionList[] = {
		{"CreateBody", b2World_CreateBody},
		{"DestroyBody", b2World_DestroyBody},
		{"Step", b2World_Step},
		{"ClearForces", b2World_ClearForces},
		{"QueryAABB", b2World_QueryAABB},
		{NULL, NULL},
	};
	binder.createClass("b2World", "EventDispatcher", b2World_create, b2World_destruct, b2World_functionList);


	//static const luaL_Reg b2MassData_functionList[] = {
	//	{NULL, NULL},
	//};
	//binder.createClass("b2MassData", NULL, b2MassData_create, b2MassData_destruct, b2MassData_functionList);


	static const luaL_Reg b2BodyDef_functionList[] = {
		{"getAngle", b2BodyDef_getAngle},
		{"setAngle", b2BodyDef_setAngle},
		{"getLinearDamping", b2BodyDef_getLinearDamping},
		{"setLinearDamping", b2BodyDef_setLinearDamping},
		{"getAngularDamping", b2BodyDef_getAngularDamping},
		{"setAngularDamping", b2BodyDef_setAngularDamping},
		{"getAllowSleep", b2BodyDef_getAllowSleep},
		{"setAllowSleep", b2BodyDef_setAllowSleep},
		{"getFixedRotation", b2BodyDef_getFixedRotation},
		{"setFixedRotation", b2BodyDef_setFixedRotation},
		{"getBullet", b2BodyDef_getBullet},
		{"setBullet", b2BodyDef_setBullet},
		{NULL, NULL},
	};
	binder.createClass("b2BodyDef", NULL, b2BodyDef_create, b2BodyDef_destruct, b2BodyDef_functionList);


	static const luaL_Reg b2Body_functionList[] = {
		//{"SetMassFromShapes", b2Body_SetMassFromShapes},
		{"GetPosition", b2Body_GetPosition},
		{"SetPosition", b2Body_SetPosition},
		{"GetAngle", b2Body_GetAngle},
		{"GetLinearVelocity", b2Body_GetLinearVelocity},
		{"SetLinearVelocity", b2Body_SetLinearVelocity},
		//{"SetMass", b2Body_SetMass},
		//{"SetXForm", b2Body_SetXForm},
		//{"GetXForm", b2Body_GetXForm},
		{"GetWorldCenter", b2Body_GetWorldCenter},
		{"GetLocalCenter", b2Body_GetLocalCenter},
		{"SetAngularVelocity", b2Body_SetAngularVelocity},
		{"GetAngularVelocity", b2Body_GetAngularVelocity},
		{"CreateFixture", b2Body_CreateFixture},
		{"DestroyFixture", b2Body_DestroyFixture},
		{"ApplyForce", b2Body_ApplyForce},
		{"ApplyTorque", b2Body_ApplyTorque},
		{"ApplyLinearImpulse", b2Body_ApplyLinearImpulse},
		{"ApplyAngularImpulse", b2Body_ApplyAngularImpulse},
		{NULL, NULL},
	};
	binder.createClass("b2Body", NULL, 0, b2Body_destruct, b2Body_functionList);



	static const luaL_Reg b2Mat22_functionList[] = {
		{NULL, NULL},
	};
	binder.createClass("b2Mat22", NULL, b2Mat22_create, b2Mat22_destruct, b2Mat22_functionList);

	//static const luaL_Reg b2XForm_functionList[] = {
	//	{NULL, NULL},
	//};
	//binder.createClass("b2XForm", NULL, b2XForm_create, b2XForm_destruct, b2XForm_functionList);

	//static const luaL_Reg b2ContactPointEvent_functionList[] = {
	//	{NULL, NULL},
	//};
	//binder.createClass("b2ContactPointEvent", "Event", b2ContactPointEvent_create, b2ContactPointEvent_destruct, b2ContactPointEvent_functionList);

	static const luaL_Reg b2ContactEvent_functionList[] = {
		{NULL, NULL},
	};
	binder.createClass("b2ContactEvent", "Event", b2ContactEvent_create, b2ContactEvent_destruct, b2ContactEvent_functionList);

	static const luaL_Reg b2FixtureDef_functionList[] = {
		{"setShape", b2FixtureDef_setShape},
		{"setDensity", b2FixtureDef_setDensity},
		{NULL, NULL},
	};
	binder.createClass("b2FixtureDef", NULL, b2FixtureDef_create, b2FixtureDef_destruct, b2FixtureDef_functionList);


	static const luaL_Reg b2Shape_functionList[] = {
		{NULL, NULL},
	};
	binder.createClass("b2Shape", NULL, 0, b2Shape_destruct, b2Shape_functionList);

	static const luaL_Reg b2Fixture_functionList[] = {
		{"GetBody", b2Fixture_GetBody},
		{"SetSensor", b2Fixture_SetSensor},
		{"IsSensor", b2Fixture_IsSensor},
		{"SetFilterData", b2Fixture_SetFilterData},
		{"GetFilterData", b2Fixture_GetFilterData},
		{NULL, NULL},
	};
	binder.createClass("b2Fixture", NULL, 0, b2Fixture_destruct, b2Fixture_functionList);


	static const luaL_Reg b2CircleShape_functionList[] = {
		{NULL, NULL},
	};
	binder.createClass("b2CircleShape", "b2Shape", b2CircleShape_create, b2CircleShape_destruct, b2CircleShape_functionList);

	static const luaL_Reg b2PolygonShape_functionList[] = {
		{"SetAsBox", b2PolygonShape_SetAsBox},
		{"SetAsEdge", b2PolygonShape_SetAsEdge},
		{"Set", b2PolygonShape_Set},
		{NULL, NULL},
	};
	binder.createClass("b2PolygonShape", "b2Shape", b2PolygonShape_create, b2PolygonShape_destruct, b2PolygonShape_functionList);


	static const luaL_Reg b2Contact_functionList[] = {
		{"GetFixtureA", b2Contact_GetFixtureA},
		{"GetFixtureB", b2Contact_GetFixtureB},
		{"IsTouching", b2Contact_IsTouching},
		{NULL, NULL},
	};
	binder.createClass("b2Contact", NULL, b2Contact_create, b2Contact_destruct, b2Contact_functionList);


	
/*	
	lua_getglobal(L, "b2ContactPointEvent");	// get metatable

	lua_pushstring(L, b2ContactPointEvent::ADD.type());
	lua_setfield(L, -2, "ADD");

	lua_pushstring(L, b2ContactPointEvent::PERSIST.type());
	lua_setfield(L, -2, "PERSIST");

	lua_pushstring(L, b2ContactPointEvent::REMOVE.type());
	lua_setfield(L, -2, "REMOVE");

	lua_pop(L, 1);
*/

	lua_getglobal(L, "b2ContactEvent");	// get metatable

	lua_pushstring(L, b2ContactEvent::BEGIN_CONTACT.type());
	lua_setfield(L, -2, "BEGIN_CONTACT");

	lua_pushstring(L, b2ContactEvent::END_CONTACT.type());
	lua_setfield(L, -2, "END_CONTACT");

	lua_pushstring(L, b2ContactEvent::PRE_SOLVE.type());
	lua_setfield(L, -2, "PRE_SOLVE");

	lua_pushstring(L, b2ContactEvent::POST_SOLVE.type());
	lua_setfield(L, -2, "POST_SOLVE");

	lua_pop(L, 1);
	
	lua_pushinteger(L, b2_staticBody);
	lua_setglobal(L, "b2_staticBody");

	lua_pushinteger(L, b2_kinematicBody);
	lua_setglobal(L, "b2_kinematicBody");

	lua_pushinteger(L, b2_dynamicBody);
	lua_setglobal(L, "b2_dynamicBody");
}


static b2Body* toBody(const Binder& binder, int index)
{
	b2Body* body = static_cast<b2Body*>(binder.getInstance("b2Body", index));

	if (body == 0)
	{
		GStatus status(5001);	// Body is already destroyed.
		luaL_error(binder.L, status.errorString());
	}

	return body;
}

static b2Shape* toShape(const Binder& binder, int index)
{
	return static_cast<b2Shape*>(binder.getInstance("b2Shape", index));
}

static b2Fixture* toFixture(const Binder& binder, int index)
{
	b2Fixture* fixture = static_cast<b2Fixture*>(binder.getInstance("b2Fixture", index));

	if (fixture == 0)
	{
		GStatus status(5002);	// Fixture is already destroyed.
		luaL_error(binder.L, status.errorString());
	}

	return fixture;
}

class b2Vec2Container
{
public:
	b2Vec2Container(b2Vec2* vec2) : vec2(vec2)
	{
	}

	b2Vec2Container(double x, double y) : vec2Instance(x, y)
	{
		vec2 = &vec2Instance;
	}

	b2Vec2* vec2;
	b2Vec2 vec2Instance;
};

static b2Vec2* toVec2(const Binder& binder, int index)
{
	return static_cast<b2Vec2Container*>(binder.getInstance("b2Vec2", index))->vec2;
}


int Box2DBinder::b2Vec2_create(lua_State* L)
{
	StackChecker checker(L, "b2Vec2_create", 1);

	Binder binder(L);

	if (lua_istable(L, 1) && lua_islightuserdata(L, 2))
	{
		b2Vec2* vec2 = static_cast<b2Vec2*>(lua_touserdata(L, 2));

		b2Vec2Container* vec2Container = new b2Vec2Container(vec2);
		binder.pushInstance("b2Vec2", vec2Container);

		lua_pushvalue(L, 1);
		lua_setfield(L, -2, "__owner");
	}
	else
	{
		double x = luaL_optnumber(L, 1, 0.0);
		double y = luaL_optnumber(L, 2, 0.0);

		b2Vec2Container* vec2Container = new b2Vec2Container(x, y);
		binder.pushInstance("b2Vec2", vec2Container);
	}

	return 1;
}

int Box2DBinder::b2Vec2_destruct(lua_State* L)
{
	void* ptr = *(void**)lua_touserdata(L, 1);
	b2Vec2Container* vec2Container = static_cast<b2Vec2Container*>(ptr);
	delete vec2Container;

	return 0;
}


int Box2DBinder::b2Vec2_getX(lua_State* L)
{
	StackChecker checker(L, "b2Vec2_getX", 1);

	Binder binder(L);
	b2Vec2* vec2 = toVec2(binder, 1);

	lua_pushnumber(L, vec2->x);

	return 1;
}

int Box2DBinder::b2Vec2_getY(lua_State* L)
{
	StackChecker checker(L, "b2Vec2_getY", 1);

	Binder binder(L);
	b2Vec2* vec2 = toVec2(binder, 1);

	lua_pushnumber(L, vec2->y);

	return 1;
}

int Box2DBinder::b2Vec2_setX(lua_State* L)
{
	StackChecker checker(L, "b2Vec2_setX", 0);

	Binder binder(L);
	b2Vec2* vec2 = toVec2(binder, 1);

	double x = luaL_checknumber(L, 2);
	vec2->x = x;

	return 0;
}

int Box2DBinder::b2Vec2_setY(lua_State* L)
{
	StackChecker checker(L, "b2Vec2_setY", 0);

	Binder binder(L);
	b2Vec2* vec2 = toVec2(binder, 1);

	double y = luaL_checknumber(L, 2);
	vec2->y = y;

	return 0;
}

int Box2DBinder::b2Vec2_Set(lua_State* L)
{
	StackChecker checker(L, "b2Vec2_Set", 0);

	Binder binder(L);
	b2Vec2* vec2 = toVec2(binder, 1);

	double x = luaL_optnumber(L, 2, 0.0);
	double y = luaL_optnumber(L, 3, 0.0);

	vec2->x = x;
	vec2->y = y;

	return 0;
}

int Box2DBinder::b2AABB_create(lua_State* L)
{
	Binder binder(L);

	b2AABB* aabb = new b2AABB;
	aabb->lowerBound.SetZero();
	aabb->upperBound.SetZero();
	binder.pushInstance("b2AABB", aabb);

	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushvalue(L, -2);
	lua_pushlightuserdata(L, &aabb->lowerBound);
	lua_call(L, 2, 1);
	lua_setfield(L, -2, "lowerBound");

	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushvalue(L, -2);
	lua_pushlightuserdata(L, &aabb->upperBound);
	lua_call(L, 2, 1);
	lua_setfield(L, -2, "upperBound");

	return 1;
}

int Box2DBinder::b2AABB_destruct(lua_State* L)
{
	void* ptr = *(void**)lua_touserdata(L, 1);
	b2AABB* aabb = static_cast<b2AABB*>(ptr);
	delete aabb;

	return 0;
}


int Box2DBinder::b2World_create(lua_State* L)
{
	Binder binder(L);

	b2Vec2* gravity = toVec2(binder, 1);
	bool doSleep = lua_toboolean(L, 2);

	b2WorldED* world = new b2WorldED(*gravity, doSleep);
	EventContactListener* contactListener = new EventContactListener(L, world);
	world->SetContactListener(contactListener);
	DestructionListener* destructionListener = new DestructionListener(L, world);
	world->SetDestructionListener(destructionListener);
	
	binder.pushInstance("b2World", world);

	lua_newtable(L);
	lua_setfield(L, -2, "__bodies");

	lua_pushlightuserdata(L, world);
	lua_pushvalue(L, -2);
	setb2(L);
	

	lua_getglobal(L, "Event");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);				// remove global "Event"

	lua_pushvalue(L, -1);	// duplicate Event.new
	lua_pushstring(L, b2ContactEvent::BEGIN_CONTACT.type());
	lua_call(L, 1, 1); // call Event.new
	lua_setfield(L, -3, "__beginContactEvent");

	lua_pushvalue(L, -1);	// duplicate Event.new
	lua_pushstring(L, b2ContactEvent::END_CONTACT.type());
	lua_call(L, 1, 1); // call Event.new
	lua_setfield(L, -3, "__endContactEvent");

	lua_pushvalue(L, -1);	// duplicate Event.new
	lua_pushstring(L, b2ContactEvent::PRE_SOLVE.type());
	lua_call(L, 1, 1); // call Event.new
	lua_setfield(L, -3, "__preSolveEvent");

	lua_pushvalue(L, -1);	// duplicate Event.new
	lua_pushstring(L, b2ContactEvent::POST_SOLVE.type());
	lua_call(L, 1, 1); // call Event.new
	lua_setfield(L, -3, "__postSolveEvent");

	lua_pop(L, 1);

	return 1;
}

int Box2DBinder::b2World_destruct(lua_State* L)
{
	void* ptr = *(void**)lua_touserdata(L, 1);
	b2WorldED* world = static_cast<b2WorldED*>(ptr);
	world->unref();

	return 0;
}

#if 0

class b2MassDataContainer
{
public:
	b2MassDataContainer(b2MassData* massData) : massData(massData), destruct(false)
	{
	}

	b2MassDataContainer() : destruct(true)
	{
		massData = new b2MassData;

		massData->mass = 0.f;
		massData->center = b2Vec2(0.f, 0.f);
		massData->I = 0.f;
	}

	b2MassDataContainer(float32 mass, const b2Vec2& center, float32 I) : destruct(true)
	{
		massData = new b2MassData;

		massData->mass = mass;
		massData->center = center;
		massData->I = I;
	}

	~b2MassDataContainer()
	{
		if (destruct == true)
			delete massData;
	}

	b2MassData* massData;
	bool destruct;
};


int Box2DBinder::b2MassData_create(lua_State* L)
{
	StackChecker checker(L, "b2MassData_create", 1);

	Binder binder(L);

	b2MassData* massData = 0;
	if (lua_istable(L, 1) && lua_islightuserdata(L, 2))
	{
		massData = static_cast<b2MassData*>(lua_touserdata(L, 2));
		b2MassDataContainer* massDataContainer = new b2MassDataContainer(massData);
		binder.pushInstance("b2MassData", massDataContainer);

		lua_pushvalue(L, 1);
		lua_setfield(L, -2, "__owner");
	}
	else
	{
		b2MassDataContainer* massDataContainer = new b2MassDataContainer;
		massData = massDataContainer->massData;
		binder.pushInstance("b2MassData", massDataContainer);
	}

	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushvalue(L, -2);
	lua_pushlightuserdata(L, &massData->center);
	lua_call(L, 2, 1);
	lua_setfield(L, -2, "center");

	return 1;
}

int Box2DBinder::b2MassData_destruct(lua_State* L)
{
	void* ptr = *(void**)lua_touserdata(L, 1);
	b2MassDataContainer* massDataContainer = static_cast<b2MassDataContainer*>(ptr);
	delete massDataContainer;

	return 0;
}

#endif


int Box2DBinder::b2BodyDef_create(lua_State* L)
{
	StackChecker checker(L, "b2BodyDef_create", 1);

	Binder binder(L);

	b2BodyDef* bodyDef = new b2BodyDef;				// note: b2BodyDef has a default constructor that initialize all member variables
	binder.pushInstance("b2BodyDef", bodyDef);

	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushvalue(L, -2);
	lua_pushlightuserdata(L, &bodyDef->position);
	lua_call(L, 2, 1);
	lua_setfield(L, -2, "position");

	return 1;
}

int Box2DBinder::b2BodyDef_destruct(lua_State* L)
{
	void* ptr = *(void**)lua_touserdata(L, 1);
	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(ptr);
	delete bodyDef;

	return 0;
}


int Box2DBinder::b2BodyDef_getAngle(lua_State* L)
{
	StackChecker checker(L, "b2BodyDef_getAngle", 1);

	Binder binder(L);
	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(binder.getInstance("b2BodyDef", 1));

	double angle = bodyDef->angle;
	lua_pushnumber(L, angle);

	return 1;
}

int Box2DBinder::b2BodyDef_setAngle(lua_State* L)
{
	StackChecker checker(L, "b2BodyDef_setAngle", 0);

	Binder binder(L);
	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(binder.getInstance("b2BodyDef", 1));

	double angle = lua_tonumber(L, 2);
	bodyDef->angle = angle;

	return 0;
}


int Box2DBinder::b2BodyDef_getLinearDamping(lua_State* L)
{
	StackChecker checker(L, "b2BodyDef_getLinearDamping", 1);

	Binder binder(L);
	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(binder.getInstance("b2BodyDef", 1));

	double linearDamping = bodyDef->linearDamping;
	lua_pushnumber(L, linearDamping);

	return 1;
}

int Box2DBinder::b2BodyDef_setLinearDamping(lua_State* L)
{
	StackChecker checker(L, "b2BodyDef_setLinearDamping", 0);

	Binder binder(L);
	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(binder.getInstance("b2BodyDef", 1));

	double linearDamping = lua_tonumber(L, 2);
	bodyDef->linearDamping = linearDamping;

	return 0;
}

int Box2DBinder::b2BodyDef_getAngularDamping(lua_State* L)
{
	StackChecker checker(L, "b2BodyDef_getAngularDamping", 1);

	Binder binder(L);
	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(binder.getInstance("b2BodyDef", 1));

	double angularDamping = bodyDef->angularDamping;
	lua_pushnumber(L, angularDamping);

	return 1;
}

int Box2DBinder::b2BodyDef_setAngularDamping(lua_State* L)
{
	StackChecker checker(L, "b2BodyDef_setAngularDamping", 0);

	Binder binder(L);
	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(binder.getInstance("b2BodyDef", 1));

	double angularDamping = lua_tonumber(L, 2);
	bodyDef->angularDamping = angularDamping;

	return 0;
}

int Box2DBinder::b2BodyDef_getAllowSleep(lua_State* L)
{
	StackChecker checker(L, "b2BodyDef_getAllowSleep", 1);

	Binder binder(L);
	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(binder.getInstance("b2BodyDef", 1));

	bool allowSleep = bodyDef->allowSleep;
	lua_pushboolean(L, allowSleep);

	return 1;
}

int Box2DBinder::b2BodyDef_setAllowSleep(lua_State* L)
{
	StackChecker checker(L, "b2BodyDef_setAllowSleep", 0);

	Binder binder(L);
	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(binder.getInstance("b2BodyDef", 1));

	bool allowSleep = lua_toboolean(L, 2);
	bodyDef->allowSleep = allowSleep;

	return 0;
}

int Box2DBinder::b2BodyDef_getFixedRotation(lua_State* L)
{
	StackChecker checker(L, "b2BodyDef_getFixedRotation", 1);

	Binder binder(L);
	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(binder.getInstance("b2BodyDef", 1));

	bool value = bodyDef->fixedRotation;
	lua_pushboolean(L, value);

	return 1;
}

int Box2DBinder::b2BodyDef_setFixedRotation(lua_State* L)
{
	StackChecker checker(L, "b2BodyDef_setFixedRotation", 0);

	Binder binder(L);
	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(binder.getInstance("b2BodyDef", 1));

	bool value = lua_toboolean(L, 2);
	bodyDef->fixedRotation = value;

	return 0;
}

int Box2DBinder::b2BodyDef_getBullet(lua_State* L)
{
	StackChecker checker(L, "b2BodyDef_getBullet", 1);

	Binder binder(L);
	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(binder.getInstance("b2BodyDef", 1));

	bool value = bodyDef->bullet;
	lua_pushboolean(L, value);

	return 1;
}

int Box2DBinder::b2BodyDef_setBullet(lua_State* L)
{
	StackChecker checker(L, "b2BodyDef_setBullet", 0);

	Binder binder(L);
	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(binder.getInstance("b2BodyDef", 1));

	bool value = lua_toboolean(L, 2);
	bodyDef->bullet = value;

	return 0;
}





int Box2DBinder::b2World_DestroyBody(lua_State* L)
{
	StackChecker checker(L, "b2World_DestroyBody", 0);

	Binder binder(L);
	b2WorldED* world = static_cast<b2WorldED*>(binder.getInstance("b2World", 1));
	b2Body* body = toBody(binder, 2);

#if 0
	// set __userdata = 0 for all fixtures of this body
	lua_getfield(L, 2, "__fixtures");
	int t = abs_index(L, -1); /* table is in the stack at index 't' */
	lua_pushnil(L);			  /* first key */
	while (lua_next(L, t) != 0)
	{
		/* uses 'key' (at index -2) and 'value' (at index -1) */
		binder.setInstance(-2, 0);
		lua_pop(L, 1);		/* removes 'value'; keeps 'key' for next iteration */
	}
	lua_pop(L, 1);

	lua_newtable(L);
	lua_setfield(L, 2, "__fixtures");
#endif

	world->DestroyBody(body);

	binder.setInstance(2, 0);	// set __userdata = 0

	
	lua_getfield(L, 1, "__bodies");
	lua_pushvalue(L, 2);
	lua_pushnil(L);
	lua_settable(L, -3);
	lua_pop(L, 1);
	
	return 0;
}

static void tableToBodyDef(lua_State* L, int index, b2BodyDef* bodyDef)
{
	// TODO: index'tekinin table oldugunu test et

	Binder binder(L);

	lua_getfield(L, index, "type");
	if (!lua_isnil(L, -1))
		bodyDef->type = static_cast<b2BodyType>(luaL_checkinteger(L, -1));
	lua_pop(L, 1);

	lua_getfield(L, index, "position");
	if (!lua_isnil(L, -1))
		bodyDef->position = *toVec2(binder, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "angle");
	if (!lua_isnil(L, -1))
		bodyDef->angle = luaL_checknumber(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "linearVelocity");
	if (!lua_isnil(L, -1))
		bodyDef->linearVelocity = *toVec2(binder, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "angularVelocity");
	if (!lua_isnil(L, -1))
		bodyDef->angularVelocity = luaL_checknumber(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "linearDamping");
	if (!lua_isnil(L, -1))
		bodyDef->linearDamping = luaL_checknumber(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "angularDamping");
	if (!lua_isnil(L, -1))
		bodyDef->angularDamping = luaL_checknumber(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "allowSleep");
	if (!lua_isnil(L, -1))
		bodyDef->allowSleep = lua_toboolean(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "awake");
	if (!lua_isnil(L, -1))
		bodyDef->awake = lua_toboolean(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "fixedRotation");
	if (!lua_isnil(L, -1))
		bodyDef->fixedRotation = lua_toboolean(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "bullet");
	if (!lua_isnil(L, -1))
		bodyDef->bullet = lua_toboolean(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "active");
	if (!lua_isnil(L, -1))
		bodyDef->active = lua_toboolean(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "inertiaScale");
	if (!lua_isnil(L, -1))
		bodyDef->inertiaScale = luaL_checknumber(L, -1);
	lua_pop(L, 1);
}


int Box2DBinder::b2World_CreateBody(lua_State* L)
{
	StackChecker checker(L, "b2World_CreateBody", 1);

	Binder binder(L);
	b2WorldED* world = static_cast<b2WorldED*>(binder.getInstance("b2World", 1));
//	b2BodyDef* bodyDef = static_cast<b2BodyDef*>(binder.getInstance("b2BodyDef", 2));

	b2BodyDef bodyDef;
	tableToBodyDef(L, 2, &bodyDef);

	b2Body* body = world->CreateBody(&bodyDef);
	binder.pushInstance("b2Body", body);

	lua_newtable(L);
	lua_setfield(L, -2, "__fixtures");

	lua_pushvalue(L, 1);
	lua_setfield(L, -2, "__world");

	lua_getfield(L, 1, "__bodies");
	lua_pushvalue(L, -2);
	lua_pushlightuserdata(L, body);
	lua_settable(L, -3);
	lua_pop(L, 1);

	return 1;
}

int Box2DBinder::b2Body_destruct(lua_State* L)
{
	void* ptr = *(void**)lua_touserdata(L, 1);
	b2Body* body = static_cast<b2Body*>(ptr);
	if (body != 0)
		body->GetWorld()->DestroyBody(body);

	return 0;
}

static void tableToFilter(lua_State* L, int index, b2Filter* filter)
{
	// TODO: index'tekinin table oldugunu test et

	Binder binder(L);

	lua_getfield(L, index, "categoryBits");
	if (!lua_isnil(L, -1))
		filter->categoryBits = luaL_checkinteger(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "maskBits");
	if (!lua_isnil(L, -1))
		filter->maskBits = luaL_checkinteger(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "groupIndex");
	if (!lua_isnil(L, -1))
		filter->groupIndex = luaL_checkinteger(L, -1);
	lua_pop(L, 1);
}

static void tableToFixtureDef(lua_State* L, int index, b2FixtureDef* fixtureDef)
{
	// TODO: index'tekinin table oldugunu test et

	Binder binder(L);

	lua_getfield(L, index, "shape");
	if (!lua_isnil(L, -1))
		fixtureDef->shape = toShape(binder, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "friction");
	if (!lua_isnil(L, -1))
		fixtureDef->friction = luaL_checknumber(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "restitution");
	if (!lua_isnil(L, -1))
		fixtureDef->restitution = luaL_checknumber(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "density");
	if (!lua_isnil(L, -1))
		fixtureDef->density = luaL_checknumber(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "isSensor");
	if (!lua_isnil(L, -1))
		fixtureDef->isSensor = lua_toboolean(L, -1);
	lua_pop(L, 1);

	lua_getfield(L, index, "filter");
	if (!lua_isnil(L, -1))
		tableToFilter(L, -1, &fixtureDef->filter);
	lua_pop(L, 1);
}


int Box2DBinder::b2Body_CreateFixture(lua_State* L)
{
	StackChecker checker(L, "b2Body_CreateFixture", 1);

	Binder binder(L);
	b2Body* body = toBody(L, 1);
	//b2FixtureDef* fixtureDef = static_cast<b2FixtureDef*>(binder.getInstance("b2FixtureDef", 2));

	b2FixtureDef fixtureDef;
	tableToFixtureDef(L, 2, &fixtureDef);
	
	b2Fixture* fixture = body->CreateFixture(&fixtureDef);
	binder.pushInstance("b2Fixture", fixture);

	lua_pushvalue(L, 1);
	lua_setfield(L, -2, "__body");

	lua_getfield(L, 1, "__fixtures");
	lua_pushvalue(L, -2);
	lua_pushlightuserdata(L, fixture);
	lua_settable(L, -3);
	lua_pop(L, 1);

	lua_pushlightuserdata(L, fixture);
	lua_pushvalue(L, -2);
	setb2(L);

	return 1;
}

int Box2DBinder::b2Body_DestroyFixture(lua_State* L)
{
	StackChecker checker(L, "b2Body_DestroyFixture", 0);

	Binder binder(L);
	b2Body* body = toBody(L, 1);
	b2Fixture* fixture = toFixture(L, 2);

	binder.setInstance(2, 0);	// set fixture.__userdata = 0
	
	body->DestroyFixture(fixture);

	lua_getfield(L, 1, "__fixtures");
	lua_pushvalue(L, 2);
	lua_pushnil(L);
	lua_settable(L, -3);
	lua_pop(L, 1);

	lua_pushlightuserdata(L, fixture);
	lua_pushnil(L);
	setb2(L);
	
	return 0;
}



int Box2DBinder::b2Body_GetPosition(lua_State* L)
{
	StackChecker checker(L, "b2Body_GetPosition", 2);

	Binder binder(L);
	b2Body* body = toBody(L, 1);

	const b2Vec2& position = body->GetPosition();

/*	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushnumber(L, position.x);
	lua_pushnumber(L, position.y);
	lua_call(L, 2, 1);
	return 1; */

	lua_pushnumber(L, position.x);
	lua_pushnumber(L, position.y);
	return 2;
}


int Box2DBinder::b2Body_SetPosition(lua_State* L)
{
	StackChecker checker(L, "b2Body_SetPosition", 0);

	Binder binder(L);
	b2Body* body = toBody(L, 1);

	lua_Number x = luaL_checknumber(L, 2);
	lua_Number y = luaL_checknumber(L, 3);
	body->SetTransform(b2Vec2(x, y), body->GetAngle());

	return 0;
}


int Box2DBinder::b2Body_GetAngle(lua_State* L)
{
	StackChecker checker(L, "b2Body_GetAngle", 1);

	Binder binder(L);
	b2Body* body = toBody(L, 1);

	double angle = body->GetAngle();
	lua_pushnumber(L, angle);

	return 1;
}

int Box2DBinder::b2Body_GetLinearVelocity(lua_State* L)
{
	StackChecker checker(L, "b2Body_GetLinearVelocity", 2);

	Binder binder(L);
	b2Body* body = toBody(L, 1);

	b2Vec2 linearVelocity = body->GetLinearVelocity();

/*	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushnumber(L, linearVelocity.x);
	lua_pushnumber(L, linearVelocity.y);
	lua_call(L, 2, 1); */

	lua_pushnumber(L, linearVelocity.x);
	lua_pushnumber(L, linearVelocity.y);

	return 2;
}

int Box2DBinder::b2Body_SetLinearVelocity(lua_State* L)
{
	StackChecker checker(L, "b2Body_SetLinearVelocity", 0);

	Binder binder(L);

	b2Body* body = toBody(L, 1);
	lua_Number x = luaL_checknumber(L, 2);
	lua_Number y = luaL_checknumber(L, 3);

	body->SetLinearVelocity(b2Vec2(x, y));

	return 0;
}

/*
int Box2DBinder::b2Body_SetMass(lua_State* L)
{
	StackChecker checker(L, "b2Body_SetMass", 0);

	Binder binder(L);

	b2Body* body = static_cast<b2Body*>(binder.getInstance("b2Body", 1));
	b2MassData* massData = static_cast<b2MassDataContainer*>(binder.getInstance("b2MassData", 2))->massData;

	body->SetMass(massData);
	
	return 0;
}

int Box2DBinder::b2Body_SetXForm(lua_State* L)
{
	StackChecker checker(L, "b2Body_SetXForm", 1);

	Binder binder(L);

	b2Body* body = toBody(binder, 1);
	b2Vec2* position = toVec2(binder, 2);
	double angle = lua_tonumber(L, 3);

	bool result = body->SetXForm(*position, angle);
	lua_pushboolean(L, result);

	return 1;
}

int Box2DBinder::b2Body_GetXForm(lua_State* L)
{
	StackChecker checker(L, "b2Body_GetXForm", 1);

	Binder binder(L);

	b2Body* body = toBody(binder, 1);
	const b2XForm& xform = body->GetXForm();

	lua_getglobal(L, "b2XForm");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);

	lua_pushlightuserdata(L, const_cast<b2XForm*>(&xform));

	lua_call(L, 1, 1);
	
	return 1;
}
*/

int Box2DBinder::b2Body_GetWorldCenter(lua_State* L)
{
	StackChecker checker(L, "b2Body_GetWorldCenter", 1);

	Binder binder(L);

	b2Body* body = toBody(binder, 1);
	const b2Vec2& worldCenter = body->GetWorldCenter();

	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushnumber(L, worldCenter.x);
	lua_pushnumber(L, worldCenter.y);
	lua_call(L, 2, 1);

	return 1;
}


int Box2DBinder::b2Body_GetLocalCenter(lua_State* L)
{
	StackChecker checker(L, "b2Body_GetLocalCenter", 1);
	
	Binder binder(L);
	
	b2Body* body = toBody(binder, 1);
	const b2Vec2& localCenter = body->GetLocalCenter();

	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushnumber(L, localCenter.x);
	lua_pushnumber(L, localCenter.y);
	lua_call(L, 2, 1);

	return 1;
}


int Box2DBinder::b2Body_SetAngularVelocity(lua_State* L)
{
	StackChecker checker(L, "b2Body_SetAngularVelocity", 0);
	
	Binder binder(L);
	
	b2Body* body = toBody(binder, 1);
	double angularVelocity = luaL_checknumber(L, 2);

	body->SetAngularVelocity(angularVelocity);
	
	return 0;
}


int Box2DBinder::b2Body_GetAngularVelocity(lua_State* L)
{
	StackChecker checker(L, "b2Body_GetAngularVelocity", 1);
	
	Binder binder(L);
	
	b2Body* body = toBody(binder, 1);
	lua_pushnumber(L, body->GetAngularVelocity());
	
	return 1;
}


int Box2DBinder::b2Body_ApplyForce(lua_State* L)
{
	StackChecker checker(L, "b2Body_ApplyForce", 0);
	
	Binder binder(L);
	
	b2Body* body = toBody(binder, 1);
	b2Vec2* force = toVec2(binder, 2);
	b2Vec2* point = toVec2(binder, 3);

	body->ApplyForce(*force, *point);

	return 0;
}

int Box2DBinder::b2Body_ApplyTorque(lua_State* L)
{
	StackChecker checker(L, "b2Body_ApplyTorque", 0);
	
	Binder binder(L);
	
	b2Body* body = toBody(binder, 1);
	lua_Number torque = luaL_checknumber(L, 2);

	body->ApplyTorque(torque);

	return 0;
}

int Box2DBinder::b2Body_ApplyLinearImpulse(lua_State* L)
{
	StackChecker checker(L, "b2Body_ApplyLinearImpulse", 0);
	
	Binder binder(L);
	
	b2Body* body = toBody(binder, 1);
	b2Vec2* impulse = toVec2(binder, 2);
	b2Vec2* point = toVec2(binder, 3);

	body->ApplyLinearImpulse(*impulse, *point);
	
	return 0;
}

int Box2DBinder::b2Body_ApplyAngularImpulse(lua_State* L)
{
	StackChecker checker(L, "b2Body_ApplyAngularImpulse", 0);
	
	Binder binder(L);
	
	b2Body* body = toBody(binder, 1);
	lua_Number impulse = luaL_checknumber(L, 2);

	body->ApplyAngularImpulse(impulse);

	return 0;
}



int Box2DBinder::b2World_Step(lua_State* L)
{
	StackChecker checker(L, "b2World_Step", 0);

	Binder binder(L);
	b2WorldED* world = static_cast<b2WorldED*>(binder.getInstance("b2World", 1));

	double timeStep = luaL_checknumber(L, 2);
	int velocityIterations = luaL_checkinteger(L, 3);
	int positionIterations = luaL_checkinteger(L, 4);

	world->Step(timeStep, velocityIterations, positionIterations);

	return 0;
}

int Box2DBinder::b2World_ClearForces(lua_State* L)
{
	StackChecker checker(L, "b2World_ClearForces", 0);

	Binder binder(L);
	b2WorldED* world = static_cast<b2WorldED*>(binder.getInstance("b2World", 1));

	world->ClearForces();

	return 0;
}


class MyQueryCallback : public b2QueryCallback
{
public:
	bool ReportFixture(b2Fixture* fixture)
	{
		fixtures.push_back(fixture);
		return true;
	}

	std::vector<b2Fixture*> fixtures;
};

int Box2DBinder::b2World_QueryAABB(lua_State* L)
{
	StackChecker checker(L, "b2World_Query", 1);

	Binder binder(L);
	b2WorldED* world = static_cast<b2WorldED*>(binder.getInstance("b2World", 1));
	b2AABB* aabb = static_cast<b2AABB*>(binder.getInstance("b2AABB", 2));

	MyQueryCallback callback;
	world->QueryAABB(&callback, *aabb);

	lua_newtable(L);

	lua_getglobal(L, "table");
	lua_getfield(L, -1, "insert"); // table.insert function

	for (std::size_t i = 0; i < callback.fixtures.size(); ++i)
	{
		b2Fixture* fixture = callback.fixtures[i];

		lua_pushvalue(L, -1);		// table.insert
		lua_pushvalue(L, -4);		// result
		getb2(L, fixture);			// fixture
		lua_call(L, 2, 0);			// table.insert(result, fixture)
	}

	lua_pop(L, 2);	// pop table and table.insert

	return 1;
}



#if 0

int Box2DBinder::b2Body_SetMassFromShapes(lua_State* L)
{
	StackChecker checker(L, "b2Body_SetMassFromShapes", 0);

	Binder binder(L);
	b2Body* body = static_cast<b2Body*>(binder.getInstance("b2Body", 1));

	body->SetMassFromShapes();

	return 0;
}

#endif

class b2Mat22Container
{
public:
	b2Mat22Container(b2Mat22* mat22) : mat22(mat22)
	{

	}

	b2Mat22Container(const b2Mat22& mat22) : mat22Instance(mat22)
	{
		this->mat22 = &mat22Instance;
	}

	b2Mat22* mat22;
	b2Mat22 mat22Instance;
};

int Box2DBinder::b2Mat22_create(lua_State* L)
{
	StackChecker checker(L, "b2Mat22_create", 1);

	Binder binder(L);

	b2Mat22* mat22 = 0;
	
	if (lua_istable(L, 1) && lua_islightuserdata(L, 2))
	{
		mat22 = static_cast<b2Mat22*>(lua_touserdata(L, 2));

		b2Mat22Container* mat22Container = new b2Mat22Container(mat22);
		binder.pushInstance("b2Mat22", mat22Container);

		lua_pushvalue(L, 1);
		lua_setfield(L, -2, "__owner");
	}
	else
	{
		// TODO: do default constructor
		if (lua_gettop(L) == 1)
		{
			double angle = luaL_checknumber(L, 1);

			b2Mat22Container* mat22Container = new b2Mat22Container(b2Mat22(angle));
			mat22 = mat22Container->mat22;
			binder.pushInstance("b2Mat22", mat22Container);
		}
		else if (lua_gettop(L) == 2)
		{
			b2Vec2* c1 = static_cast<b2Vec2Container*>(binder.getInstance("b2Vec2", 1))->vec2;
			b2Vec2* c2 = static_cast<b2Vec2Container*>(binder.getInstance("b2Vec2", 2))->vec2;

			b2Mat22Container* mat22Container = new b2Mat22Container(b2Mat22(*c1, *c2));
			mat22 = mat22Container->mat22;
			binder.pushInstance("b2Mat22", mat22Container);
		}
		else
		{
			double a11 = luaL_checknumber(L, 1);
			double a12 = luaL_checknumber(L, 2);
			double a21 = luaL_checknumber(L, 3);
			double a22 = luaL_checknumber(L, 4);

			b2Mat22Container* mat22Container = new b2Mat22Container(b2Mat22(a11, a12, a21, a22));
			mat22 = mat22Container->mat22;
			binder.pushInstance("b2Mat22", mat22Container);
		}
	}

	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushvalue(L, -2);
	lua_pushlightuserdata(L, &mat22->col1);
	lua_call(L, 2, 1);
	lua_setfield(L, -2, "col1");

	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushvalue(L, -2);
	lua_pushlightuserdata(L, &mat22->col2);
	lua_call(L, 2, 1);
	lua_setfield(L, -2, "col2");

	return 1;
}

int Box2DBinder::b2Mat22_destruct(lua_State* L)
{
	void* ptr = *(void**)lua_touserdata(L, 1);
	b2Mat22Container* mat22Container = static_cast<b2Mat22Container*>(ptr);
	delete mat22Container;

	return 0;
}

#if 0

class b2XFormContainer
{
public:
	b2XFormContainer(b2XForm* xform) : xform(xform), destruct(false)
	{
	}

	b2XFormContainer(const b2XForm& xform) : xform(new b2XForm(xform)), destruct(true)
	{
	}

	~b2XFormContainer()
	{
		if (destruct == true)
			delete xform;
	}

	b2XForm* xform;
	bool destruct;
};

#endif

/*
int Box2DBinder::b2XForm_create(lua_State* L)
{
	StackChecker checker(L, "b2XForm_create", 1);

	Binder binder(L);

	b2XForm* xform = 0;
	
	if (lua_istable(L, 1) && lua_islightuserdata(L, 2))
	{
		xform = static_cast<b2XForm*>(lua_touserdata(L, 2));

		b2XFormContainer* xformContainer = new b2XFormContainer(xform);
		binder.pushInstance("b2XForm", xformContainer);

		lua_pushvalue(L, 1);
		lua_setfield(L, -2, "__owner");
	}
	else if (lua_islightuserdata(L, 1))
	{
		b2XFormContainer* xformContainer = new b2XFormContainer(*static_cast<b2XForm*>(lua_touserdata(L, 1)));
		xform = xformContainer->xform;
		binder.pushInstance("b2XForm", xformContainer);
	}
	else
	{
		// TODO: do default constructor
		b2Vec2* position = static_cast<b2Vec2Container*>(binder.getInstance("b2Vec2", 1))->vec2;
		b2Mat22* R = static_cast<b2Mat22Container*>(binder.getInstance("b2Mat22", 2))->mat22;

		b2XFormContainer* xformContainer = new b2XFormContainer(b2XForm(*position, *R));
		xform = xformContainer->xform;
		binder.pushInstance("b2XForm", xformContainer);
	}

	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushvalue(L, -2);
	lua_pushlightuserdata(L, &xform->position);
	lua_call(L, 2, 1);
	lua_setfield(L, -2, "position");

	lua_getglobal(L, "b2Mat22");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushvalue(L, -2);
	lua_pushlightuserdata(L, &xform->R);
	lua_call(L, 2, 1);
	lua_setfield(L, -2, "R");
	
	return 1;
}

int Box2DBinder::b2XForm_destruct(lua_State* L)
{
	void* ptr = *(void**)lua_touserdata(L, 1);
	b2XFormContainer* xformContainer = static_cast<b2XFormContainer*>(ptr);
	delete xformContainer;

	return 0;
}
*/

#if 0

int Box2DBinder::b2ContactPointEvent_create(lua_State* L)
{
	StackChecker checker(L, "b2ContactPointEvent_create", 1);

	Binder binder(L);

	b2ContactPointEvent* contactPointEvent = static_cast<b2ContactPointEvent*>(lua_touserdata(L, 1));
	const b2ContactPoint* contactPoint = contactPointEvent->point;

	binder.pushInstance("b2ContactPointEvent", 0);

	lua_pushstring(L, contactPointEvent->type());
	lua_setfield(L, -2, "__type");

	lua_pushlightuserdata(L, contactPoint->shape1);
	getb2(L);
	lua_setfield(L, -2, "shape1");
	
	lua_pushlightuserdata(L, contactPoint->shape2);
	getb2(L);
	lua_setfield(L, -2, "shape2");

	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushnumber(L, contactPoint->position.x);
	lua_pushnumber(L, contactPoint->position.y);
	lua_call(L, 2, 1);
	lua_setfield (L, -2, "position");
	
	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushnumber(L, contactPoint->velocity.x);
	lua_pushnumber(L, contactPoint->velocity.y);
	lua_call(L, 2, 1);
	lua_setfield (L, -2, "velocity");

	lua_getglobal(L, "b2Vec2");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushnumber(L, contactPoint->normal.x);
	lua_pushnumber(L, contactPoint->normal.y);
	lua_call(L, 2, 1);
	lua_setfield (L, -2, "normal");

	lua_pushnumber(L, contactPoint->separation);
	lua_setfield (L, -2, "separation");
	
	lua_pushnumber(L, contactPoint->friction);
	lua_setfield (L, -2, "friction");

	lua_pushnumber(L, contactPoint->restitution);
	lua_setfield (L, -2, "restitution");

	//TODO: b2ContactID id'yi aktarmadik
	
	return 1;
}


int Box2DBinder::b2ContactPointEvent_destruct(lua_State* L)
{
	return 0;
}


#endif

int Box2DBinder::b2FixtureDef_create(lua_State* L)
{
	StackChecker checker(L, "b2FixtureDef_create", 1);

	Binder binder(L);

	b2FixtureDef* fixtureDef = new b2FixtureDef;
	binder.pushInstance("b2FixtureDef", fixtureDef);

	return 1;
}

int Box2DBinder::b2FixtureDef_destruct(lua_State* L)
{
	void* ptr = *(void**)lua_touserdata(L, 1);
	b2FixtureDef* fixtureDef = static_cast<b2FixtureDef*>(ptr);
	delete fixtureDef;

	return 0;
}

int Box2DBinder::b2FixtureDef_setShape(lua_State* L)
{
	StackChecker checker(L, "b2FixtureDef_setShape", 0);

	Binder binder(L);

	b2FixtureDef* fixtureDef = static_cast<b2FixtureDef*>(binder.getInstance("b2FixtureDef", 1));
	b2Shape* shape = static_cast<b2Shape*>(binder.getInstance("b2Shape", 2));

	lua_pushvalue(L, 2);
	lua_setfield(L, 1, "__shape");

	fixtureDef->shape = shape;

	return 0;
}

int Box2DBinder::b2FixtureDef_setDensity(lua_State* L)
{
	StackChecker checker(L, "b2FixtureDef_setDensity", 0);

	Binder binder(L);

	b2FixtureDef* fixtureDef = static_cast<b2FixtureDef*>(binder.getInstance("b2FixtureDef", 1));
	lua_Number density = lua_tonumber(L, 2);

	fixtureDef->density = density;

	return 0;
}


int Box2DBinder::b2Fixture_destruct(lua_State* L)
{
	void* ptr = *(void**)lua_touserdata(L, 1);
	b2Fixture* fixture = static_cast<b2Fixture*>(ptr);
	if (fixture != 0)
		fixture->GetBody()->DestroyFixture(fixture);

	return 0;
}

int Box2DBinder::b2Fixture_GetBody(lua_State* L)
{
	StackChecker checker(L, "b2Fixture_GetBody", 1);

	Binder binder(L);

	b2Fixture* fixture = toFixture(L, 1);

	lua_getfield(L, 1, "__body");

	return 1;
}

int Box2DBinder::b2Fixture_SetSensor(lua_State* L)
{
	StackChecker checker(L, "b2Fixture_SetSensor", 0);

	Binder binder(L);

	b2Fixture* fixture = toFixture(L, 1);
	bool sensor = lua_toboolean(L, 2);

	fixture->SetSensor(sensor);

	return 0;
}

int Box2DBinder::b2Fixture_IsSensor(lua_State* L)
{
	StackChecker checker(L, "b2Fixture_IsSensor", 1);

	Binder binder(L);

	b2Fixture* fixture = toFixture(L, 1);

	lua_pushboolean(L, fixture->IsSensor());

	return 1;
}




int Box2DBinder::b2Fixture_SetFilterData(lua_State* L)
{
	StackChecker checker(L, "b2Fixture_SetFilterData", 0);

	Binder binder(L);

	b2Fixture* fixture = toFixture(L, 1);
	b2Filter filter;
	tableToFilter(L, 2, &filter);

	fixture->SetFilterData(filter);

	return 0;
}

int Box2DBinder::b2Fixture_GetFilterData(lua_State* L)
{
	StackChecker checker(L, "b2Fixture_GetFilterData", 1);

	Binder binder(L);

	b2Fixture* fixture = toFixture(L, 1);

	const b2Filter& filter = fixture->GetFilterData();

	lua_newtable(L);

	lua_pushinteger(L, filter.categoryBits);
	lua_setfield(L, -2, "categoryBits");

	lua_pushinteger(L, filter.maskBits);
	lua_setfield(L, -2, "maskBits");

	lua_pushinteger(L, filter.groupIndex);
	lua_setfield(L, -2, "groupIndex");
	
	return 1;
}



int Box2DBinder::b2Shape_destruct(lua_State* L)
{
	void* ptr = *(void**)lua_touserdata(L, 1);
	b2Shape* shape = static_cast<b2Shape*>(ptr);
	delete shape;

	return 0;
}


int Box2DBinder::b2CircleShape_create(lua_State* L)
{
	StackChecker checker(L, "b2CircleShape_create", 1);

	Binder binder(L);

	b2Vec2* position = toVec2(L, 1);
	lua_Number radius = luaL_checknumber(L, 2);

	b2CircleShape* circleShape = new b2CircleShape;
	circleShape->m_p = *position;
	circleShape->m_radius = radius;

	binder.pushInstance("b2CircleShape", circleShape);
	
	return 1;
}

int Box2DBinder::b2CircleShape_destruct(lua_State* L)
{
	void* ptr = *(void**)lua_touserdata(L, 1);
	b2CircleShape* circleShape = static_cast<b2CircleShape*>(ptr);
	delete circleShape;

	return 0;
}


int Box2DBinder::b2PolygonShape_create(lua_State* L)
{
	StackChecker checker(L, "b2PolygonShape_create", 1);

	Binder binder(L);

	b2PolygonShape* polygonShape = new b2PolygonShape;

	binder.pushInstance("b2PolygonShape", polygonShape);
	
	return 1;
}

int Box2DBinder::b2PolygonShape_destruct(lua_State* L)
{
	void* ptr = *(void**)lua_touserdata(L, 1);
	b2PolygonShape* polygonShape = static_cast<b2PolygonShape*>(ptr);
	delete polygonShape;

	return 0;
}


int Box2DBinder::b2PolygonShape_SetAsBox(lua_State* L)
{
	StackChecker checker(L, "b2PolygonShape_SetAsBox", 0);

	Binder binder(L);
	b2PolygonShape* polygonShape = static_cast<b2PolygonShape*>(binder.getInstance("b2PolygonShape", 1));


	if (lua_gettop(L) >= 5)
	{
		lua_Number hx = luaL_checknumber(L, 2);
		lua_Number hy = luaL_checknumber(L, 3);
		b2Vec2* center = toVec2(binder, 4);
		lua_Number angle = luaL_checknumber(L, 5);

		polygonShape->SetAsBox(hx, hy, *center, angle);
	}
	else
	{
		lua_Number hx = luaL_checknumber(L, 2);
		lua_Number hy = luaL_checknumber(L, 3);

		polygonShape->SetAsBox(hx, hy);
	}

	return 0;
}

int Box2DBinder::b2PolygonShape_SetAsEdge(lua_State* L)
{
	StackChecker checker(L, "b2PolygonShape_SetAsEdge", 0);

	Binder binder(L);
	b2PolygonShape* polygonShape = static_cast<b2PolygonShape*>(binder.getInstance("b2PolygonShape", 1));

	b2Vec2* v1 = toVec2(binder, 2);
	b2Vec2* v2 = toVec2(binder, 3);
	
	polygonShape->SetAsEdge(*v1, *v2);

	return 0;
}


int Box2DBinder::b2PolygonShape_Set(lua_State* L)
{
	StackChecker checker(L, "b2PolygonShape_Set", 0);

	Binder binder(L);
	b2PolygonShape* polygonShape = static_cast<b2PolygonShape*>(binder.getInstance("b2PolygonShape", 1));

	std::vector<b2Vec2> vertices;

	int n = lua_gettop(L);

	b2Vec2 v;
	for (int i = 2; i <= n; i++)
	{
		lua_Number d = luaL_checknumber(L, i);

		if (i % 2 == 0)
			v.x = d;
		else
		{
			v.y = d;
			vertices.push_back(v);
		}
	}

	// TODO: b2PolygonShape::Set'deki tum testleri burada yap. (vertex count, zero length edges, convex, etc.)
	polygonShape->Set(&vertices[0], vertices.size());

	return 0;
}

int Box2DBinder::b2Contact_create(lua_State* L)
{
	StackChecker checker(L, "b2Contact_create", 1);

	Binder binder(L);

	b2Contact* contact = static_cast<b2Contact*>(lua_touserdata(L, 1));
	binder.pushInstance("b2Contact", contact);

	return 1;
}

int Box2DBinder::b2Contact_destruct(lua_State* L)
{
	return 0;
}


int Box2DBinder::b2Contact_GetFixtureA(lua_State* L)
{
	StackChecker checker(L, "b2Contact_GetFixtureA", 1);

	Binder binder(L);
	b2Contact* contact = static_cast<b2Contact*>(binder.getInstance("b2Contact", 1));

	b2Fixture* fixture = contact->GetFixtureA();

	getb2(L, fixture);

	return 1;
}

int Box2DBinder::b2Contact_IsTouching(lua_State* L)
{
	StackChecker checker(L, "b2Contact_IsTouching", 1);

	Binder binder(L);

	b2Contact* contact = static_cast<b2Contact*>(binder.getInstance("b2Contact", 1));

	lua_pushboolean(L, contact->IsTouching());

	return 1;
}


int Box2DBinder::b2Contact_GetFixtureB(lua_State* L)
{
	StackChecker checker(L, "b2Contact_GetFixtureB", 1);

	Binder binder(L);
	b2Contact* contact = static_cast<b2Contact*>(binder.getInstance("b2Contact", 1));

	b2Fixture* fixture = contact->GetFixtureB();

	getb2(L, fixture);

	return 1;
}

	

int Box2DBinder::b2ContactEvent_create(lua_State* L)
{
	StackChecker checker(L, "b2ContactEvent_create", 1);

	Binder binder(L);

	b2ContactEvent* contactEvent = static_cast<b2ContactEvent*>(lua_touserdata(L, 1));

	binder.pushInstance("b2ContactEvent", contactEvent);

	b2Contact* contact = contactEvent->contact;
	const b2Manifold* oldManifold = contactEvent->oldManifold;
	const b2ContactImpulse* impulse = contactEvent->impulse;

	lua_getglobal(L, "b2Contact");
	lua_getfield(L, -1, "new");
	lua_remove(L, -2);
	lua_pushlightuserdata(L, contact);
	lua_call(L, 1, 1);

	lua_setfield(L, -2, "contact");

	if (oldManifold)	// TODO
	{

	}

	if (impulse)	// TODO
	{

	}

	return 1;
}

int Box2DBinder::b2ContactEvent_destruct(lua_State* L)
{
	return 0;
}
